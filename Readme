# pocandroid â€” Cross-Platform Mobile Automation Framework

# ğŸ“Œ Overview

`pocandroid` is a production-grade, cross-platform mobile automation framework for Android and iOS, built using Appium + Java + Maven.
It follows MAANG-level design principles: clean separation of concerns, configuration-driven execution, reusable utilities, and scalable architecture.

The framework supports:

 Local execution (emulator / simulator / real device)
 Cloud execution (BrowserStack)
 Single codebase for Android & iOS
 BDD-style tests with Cucumber
 Enterprise-ready reporting and CI integration

---

# âœ¨ Key Capabilities

 âœ… Android & iOS support with shared test logic
 âœ… Local & cloud execution without code changes
 âœ… Page Object Model (POM)
 âœ… Unified locator strategy (JSON + enums)
 âœ… Secure configuration & secret handling
 âœ… Programmatic Appium server management
 âœ… Extent HTML reporting with screenshots & videos
 âœ… CI/CD ready (Jenkins, GitHub Actions, Azure DevOps)

---

# ğŸ§± Architecture & Tech Stack

| Layer                 | Technology / Pattern               | Responsibility                       |
| --------------------- | ---------------------------------- | ------------------------------------ |
| Test Definition   | Cucumber (BDD), Gherkin            | Human-readable scenarios             |
| Execution Engine  | Java + Maven + Cucumber Runner     | Scenario execution lifecycle         |
| Design Pattern    | Page Object Model (POM)            | Separation of UI & test logic        |
| Locator Strategy  | JSON locators + Enum keys          | Unified Android/iOS locators         |
| Driver Management | Factory Pattern                    | Local & BrowserStack driver creation |
| Appium Handling   | Programmatic server start/stop     | Zero manual Appium dependency        |
| Utilities         | Gestures, waits, context switching | Cross-platform abstraction           |
| Configuration     | Properties + JSON                  | Environment & platform switching     |
| Reporting         | Extent Reports                     | HTML reports with screenshots/videos |
| CI/CD             | Maven CLI                          | Pipeline-friendly execution          |

---

# ğŸ“ Project Structure

```
pocandroid/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/java/            # Framework core (driver, utils, base classes)
â”‚   â”œâ”€â”€ main/resources/       # Configs, capabilities, locator JSON
â”‚   â”œâ”€â”€ test/java/            # Tests, pages, steps, hooks, listeners
â”‚   â””â”€â”€ test/resources/       # Feature files & test data
â”œâ”€â”€ pom.xml                   # Maven build & dependencies
â”œâ”€â”€ README.md                 # Documentation
â””â”€â”€ test-output/              # Reports, screenshots, videos
```

---

# âš™ï¸ Configuration Model (Important)

# Execution Control

| Key        | Purpose                   |
| ---------- | ------------------------- |
| `run_env`  | `local` or `browserstack` |
| `platform` | `android` or `ios`        |

# Config Sources

 `config.properties` â†’ Common defaults
 `local.properties` â†’ Local-only settings (recording, paths)
 `browserstack.json` â†’ Cloud capability templates
 Secrets â†’ Encrypted or environment variables

---

# ğŸ–¥ï¸ Local Execution

# Prerequisites

 Java 11+
 Maven
 Node.js + Appium 2.x
 Android SDK or Xcode (based on platform)

# Steps

1. Set in `config.properties`:

   ```properties
   run_env=local
   platform=android
   ```
2. Update `local.json` with device/app details
3. Run:

   ```bash
   mvn clean test
   ```

Appium server starts automatically and stops after execution.

---

# â˜ï¸ Cloud Execution (BrowserStack)

# Steps

1. Upload app to BrowserStack and note `bs://` app id
2. Set encrypted values in environment config:

   ```properties
   run_env=browserstack
   bs_app=bs://xxxx
   ```
3. Run:

   ```bash
   mvn clean test
   ```

âœ” BrowserStack handles:

 Device provisioning
 Video recording
 Logs & network capture

---

# ğŸ¥ Video & Screenshot Handling

| Mode             | Behavior                               |
| ---------------- | -------------------------------------- |
| Local        | Optional recording (config-controlled) |
| BrowserStack | Always recorded by cloud               |

 Screenshots auto-attached on failure
 Videos saved under `test-output/videos` (local only)

---

# ğŸ“Š Reporting

The framework uses Extent Reports for clear, offline HTML reporting.

# Listener Components

 ExtentManager â†’ Initializes report & path
 ExtentTestManager â†’ Manages test lifecycle
 ExtentTestNGListener â†’ Logs pass/fail/skip, attaches screenshots

Reports are generated under:

```
test-output/extent-report.html
```

---

# ğŸ§ª Locator Strategy (Unified Android & iOS)

 Single locator definition per element
 JSON structure contains both `android` and `ios` blocks
 Runtime platform decides locator resolution
 Enum keys ensure compile-time safety

âœ” Same tests
âœ” Same pages
âœ” One codebase

---

# ğŸ” Security & Best Practices

 âŒ No credentials in code
 âŒ No secrets in JSON
 âœ… Encrypted properties / env vars
 âœ… Masked logs
 âœ… CI-safe configuration

---

# ğŸ› ï¸ Common Issues & Fixes

| Issue                | Resolution                              |
| -------------------- | --------------------------------------- |
| Appium port busy     | Kill existing process or change port    |
| App not launching    | Verify app path / package & activity    |
| iOS signing error    | Validate IPA, UDID, provisioning        |
| BrowserStack failure | Check credentials & uploaded app        |
| Missing recordings   | Ensure `record_video=true` (local only) |

---

# ğŸ¯ Why This Framework?

 Scales from POC to enterprise
 Minimal duplication
 Clear ownership of responsibilities
 Easy onboarding for new engineers
 Ready for CI/CD pipelines

---

# ğŸ§© Whatâ€™s Included

 Driver factories (Local & BrowserStack)
 Programmatic Appium management
 Unified locator system
 Page Object Model
 Cross-platform utilities
 Config-driven execution
 Extent reporting
 Sample test scaffolding

---

# Write Script Using BDD Usage Examples

## ğŸ“˜ Overview
This document explains how to manage test data effectively using **BDD Usage Examples** (`Scenario Outline` + `Examples`) in mobile automation testing.
Poor test data management often results in duplicated scenarios, hard-coded values, flaky tests, and high maintenance effort. BDD Usage Examples provide a **structured, readable, and maintainable approach** to handle test data while keeping scenarios aligned with business behavior.
This approach is especially useful for **mobile automation projects using Appium and Cucumber**.
---

## ğŸ¯ Purpose

The purpose of this document is to:

- Demonstrate how BDD Usage Examples can be used for test data management
- Eliminate hard-coded test data from automation code
- Improve test readability for business stakeholders
- Scale test coverage without duplicating scenarios
- Promote clean and maintainable BDD feature files

---

## ğŸ§© Role of BDD Usage Examples in Test Data Management

BDD Usage Examples help by:

- Centralizing test data inside `Examples` tables
- Separating behavior from data
- Supporting positive, negative, and edge-case scenarios
- Improving collaboration between QA, Dev, and Business teams

> In BDD, **Examples act as a lightweight test data repository** at the feature-file level.
---

## ğŸ§ª Basic Test BDD Example

```gherkin
Scenario Outline: Login validation
  Given user is on login screen
  When user logs in with "<username>" and "<password>"
  Then login result should be "<result>"

Examples:
  | username | password | result  |
  | valid1  | pass123  | success |
  | invalid | wrong    | failure |

```Stepdefination_File
When user logs in with "<username>" and "<password>"

  @When("user logs in with \"(.*)\" and \"(.*)\"")
  public void login(String user, String pass) {
      loginPage.login(user, pass);
  }

# Result
- Test data controlled from feature files
- Reusable step definitions
- Easier updates when data changes

# When test coverage grows, Examples allow scaling test data without increasing scenario count.

Examples:
| username | password | result |
| user1 | pass123 | success |
| user2 | pass123 | success |
| user3 | wrong | failure |
| user4 | empty | failure |



# ğŸš€ Recommended Workflow

1. Clone repo
2. Update configs for platform & environment
3. Run tests locally or on cloud
4. Review reports in `test-output`
5. Add pages & scenarios using existing patterns

---

#Pending stacks on the pipeleine

1. Rest assured Api support
2. Retry analyzer
3. OS specfic driver invocation
4. Suite Development/Cucmber Tag
5. Parallel Scaling 20 devices on browser stack


# ğŸ Final Note

This repository is designed to reflect real-world,  mobile automation standards â€” clean, secure, extensible, and production-ready.

---
